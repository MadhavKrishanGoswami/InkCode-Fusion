{"ast":null,"code":"import { parser } from '@lezer/python';\nimport { syntaxTree, LRLanguage, indentNodeProp, delimitedIndent, foldNodeProp, foldInside, LanguageSupport } from '@codemirror/language';\nimport { NodeWeakMap, IterMode } from '@lezer/common';\nimport { snippetCompletion, ifNotIn, completeFromList } from '@codemirror/autocomplete';\nconst cache = /*@__PURE__*/new NodeWeakMap();\nconst ScopeNodes = /*@__PURE__*/new Set([\"Script\", \"Body\", \"FunctionDefinition\", \"ClassDefinition\", \"LambdaExpression\", \"ForStatement\", \"MatchClause\"]);\nfunction defID(type) {\n  return (node, def, outer) => {\n    if (outer) return false;\n    let id = node.node.getChild(\"VariableName\");\n    if (id) def(id, type);\n    return true;\n  };\n}\nconst gatherCompletions = {\n  FunctionDefinition: /*@__PURE__*/defID(\"function\"),\n  ClassDefinition: /*@__PURE__*/defID(\"class\"),\n  ForStatement(node, def, outer) {\n    if (outer) for (let child = node.node.firstChild; child; child = child.nextSibling) {\n      if (child.name == \"VariableName\") def(child, \"variable\");else if (child.name == \"in\") break;\n    }\n  },\n  ImportStatement(_node, def) {\n    var _a, _b;\n    let {\n      node\n    } = _node;\n    let isFrom = ((_a = node.firstChild) === null || _a === void 0 ? void 0 : _a.name) == \"from\";\n    for (let ch = node.getChild(\"import\"); ch; ch = ch.nextSibling) {\n      if (ch.name == \"VariableName\" && ((_b = ch.nextSibling) === null || _b === void 0 ? void 0 : _b.name) != \"as\") def(ch, isFrom ? \"variable\" : \"namespace\");\n    }\n  },\n  AssignStatement(node, def) {\n    for (let child = node.node.firstChild; child; child = child.nextSibling) {\n      if (child.name == \"VariableName\") def(child, \"variable\");else if (child.name == \":\" || child.name == \"AssignOp\") break;\n    }\n  },\n  ParamList(node, def) {\n    for (let prev = null, child = node.node.firstChild; child; child = child.nextSibling) {\n      if (child.name == \"VariableName\" && (!prev || !/\\*|AssignOp/.test(prev.name))) def(child, \"variable\");\n      prev = child;\n    }\n  },\n  CapturePattern: /*@__PURE__*/defID(\"variable\"),\n  AsPattern: /*@__PURE__*/defID(\"variable\"),\n  __proto__: null\n};\nfunction getScope(doc, node) {\n  let cached = cache.get(node);\n  if (cached) return cached;\n  let completions = [],\n    top = true;\n  function def(node, type) {\n    let name = doc.sliceString(node.from, node.to);\n    completions.push({\n      label: name,\n      type\n    });\n  }\n  node.cursor(IterMode.IncludeAnonymous).iterate(node => {\n    if (node.name) {\n      let gather = gatherCompletions[node.name];\n      if (gather && gather(node, def, top) || !top && ScopeNodes.has(node.name)) return false;\n      top = false;\n    } else if (node.to - node.from > 8192) {\n      // Allow caching for bigger internal nodes\n      for (let c of getScope(doc, node.node)) completions.push(c);\n      return false;\n    }\n  });\n  cache.set(node, completions);\n  return completions;\n}\nconst Identifier = /^[\\w\\xa1-\\uffff][\\w\\d\\xa1-\\uffff]*$/;\nconst dontComplete = [\"String\", \"FormatString\", \"Comment\", \"PropertyName\"];\n/**\nCompletion source that looks up locally defined names in\nPython code.\n*/\nfunction localCompletionSource(context) {\n  let inner = syntaxTree(context.state).resolveInner(context.pos, -1);\n  if (dontComplete.indexOf(inner.name) > -1) return null;\n  let isWord = inner.name == \"VariableName\" || inner.to - inner.from < 20 && Identifier.test(context.state.sliceDoc(inner.from, inner.to));\n  if (!isWord && !context.explicit) return null;\n  let options = [];\n  for (let pos = inner; pos; pos = pos.parent) {\n    if (ScopeNodes.has(pos.name)) options = options.concat(getScope(context.state.doc, pos));\n  }\n  return {\n    options,\n    from: isWord ? inner.from : context.pos,\n    validFor: Identifier\n  };\n}\nconst globals = /*@__PURE__*/[\"__annotations__\", \"__builtins__\", \"__debug__\", \"__doc__\", \"__import__\", \"__name__\", \"__loader__\", \"__package__\", \"__spec__\", \"False\", \"None\", \"True\"].map(n => ({\n  label: n,\n  type: \"constant\"\n})).concat( /*@__PURE__*/[\"ArithmeticError\", \"AssertionError\", \"AttributeError\", \"BaseException\", \"BlockingIOError\", \"BrokenPipeError\", \"BufferError\", \"BytesWarning\", \"ChildProcessError\", \"ConnectionAbortedError\", \"ConnectionError\", \"ConnectionRefusedError\", \"ConnectionResetError\", \"DeprecationWarning\", \"EOFError\", \"Ellipsis\", \"EncodingWarning\", \"EnvironmentError\", \"Exception\", \"FileExistsError\", \"FileNotFoundError\", \"FloatingPointError\", \"FutureWarning\", \"GeneratorExit\", \"IOError\", \"ImportError\", \"ImportWarning\", \"IndentationError\", \"IndexError\", \"InterruptedError\", \"IsADirectoryError\", \"KeyError\", \"KeyboardInterrupt\", \"LookupError\", \"MemoryError\", \"ModuleNotFoundError\", \"NameError\", \"NotADirectoryError\", \"NotImplemented\", \"NotImplementedError\", \"OSError\", \"OverflowError\", \"PendingDeprecationWarning\", \"PermissionError\", \"ProcessLookupError\", \"RecursionError\", \"ReferenceError\", \"ResourceWarning\", \"RuntimeError\", \"RuntimeWarning\", \"StopAsyncIteration\", \"StopIteration\", \"SyntaxError\", \"SyntaxWarning\", \"SystemError\", \"SystemExit\", \"TabError\", \"TimeoutError\", \"TypeError\", \"UnboundLocalError\", \"UnicodeDecodeError\", \"UnicodeEncodeError\", \"UnicodeError\", \"UnicodeTranslateError\", \"UnicodeWarning\", \"UserWarning\", \"ValueError\", \"Warning\", \"ZeroDivisionError\"].map(n => ({\n  label: n,\n  type: \"type\"\n}))).concat( /*@__PURE__*/[\"bool\", \"bytearray\", \"bytes\", \"classmethod\", \"complex\", \"float\", \"frozenset\", \"int\", \"list\", \"map\", \"memoryview\", \"object\", \"range\", \"set\", \"staticmethod\", \"str\", \"super\", \"tuple\", \"type\"].map(n => ({\n  label: n,\n  type: \"class\"\n}))).concat( /*@__PURE__*/[\"abs\", \"aiter\", \"all\", \"anext\", \"any\", \"ascii\", \"bin\", \"breakpoint\", \"callable\", \"chr\", \"compile\", \"delattr\", \"dict\", \"dir\", \"divmod\", \"enumerate\", \"eval\", \"exec\", \"exit\", \"filter\", \"format\", \"getattr\", \"globals\", \"hasattr\", \"hash\", \"help\", \"hex\", \"id\", \"input\", \"isinstance\", \"issubclass\", \"iter\", \"len\", \"license\", \"locals\", \"max\", \"min\", \"next\", \"oct\", \"open\", \"ord\", \"pow\", \"print\", \"property\", \"quit\", \"repr\", \"reversed\", \"round\", \"setattr\", \"slice\", \"sorted\", \"sum\", \"vars\", \"zip\"].map(n => ({\n  label: n,\n  type: \"function\"\n})));\nconst snippets = [/*@__PURE__*/snippetCompletion(\"def ${name}(${params}):\\n\\t${}\", {\n  label: \"def\",\n  detail: \"function\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"for ${name} in ${collection}:\\n\\t${}\", {\n  label: \"for\",\n  detail: \"loop\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"while ${}:\\n\\t${}\", {\n  label: \"while\",\n  detail: \"loop\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"try:\\n\\t${}\\nexcept ${error}:\\n\\t${}\", {\n  label: \"try\",\n  detail: \"/ except block\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"if ${}:\\n\\t\\n\", {\n  label: \"if\",\n  detail: \"block\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"if ${}:\\n\\t${}\\nelse:\\n\\t${}\", {\n  label: \"if\",\n  detail: \"/ else block\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"class ${name}:\\n\\tdef __init__(self, ${params}):\\n\\t\\t\\t${}\", {\n  label: \"class\",\n  detail: \"definition\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"import ${module}\", {\n  label: \"import\",\n  detail: \"statement\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"from ${module} import ${names}\", {\n  label: \"from\",\n  detail: \"import\",\n  type: \"keyword\"\n})];\n/**\nAutocompletion for built-in Python globals and keywords.\n*/\nconst globalCompletion = /*@__PURE__*/ifNotIn(dontComplete, /*@__PURE__*/completeFromList( /*@__PURE__*/globals.concat(snippets)));\nfunction indentBody(context, node) {\n  let base = context.baseIndentFor(node);\n  let line = context.lineAt(context.pos, -1),\n    to = line.from + line.text.length;\n  // Don't consider blank, deindented lines at the end of the\n  // block part of the block\n  if (/^\\s*($|#)/.test(line.text) && context.node.to < to + 100 && !/\\S/.test(context.state.sliceDoc(to, context.node.to)) && context.lineIndent(context.pos, -1) <= base) return null;\n  // A normally deindenting keyword that appears at a higher\n  // indentation than the block should probably be handled by the next\n  // level\n  if (/^\\s*(else:|elif |except |finally:)/.test(context.textAfter) && context.lineIndent(context.pos, -1) > base) return null;\n  return base + context.unit;\n}\n/**\nA language provider based on the [Lezer Python\nparser](https://github.com/lezer-parser/python), extended with\nhighlighting and indentation information.\n*/\nconst pythonLanguage = /*@__PURE__*/LRLanguage.define({\n  name: \"python\",\n  parser: /*@__PURE__*/parser.configure({\n    props: [/*@__PURE__*/indentNodeProp.add({\n      Body: context => {\n        var _a;\n        return (_a = indentBody(context, context.node)) !== null && _a !== void 0 ? _a : context.continue();\n      },\n      IfStatement: cx => /^\\s*(else:|elif )/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),\n      TryStatement: cx => /^\\s*(except |finally:|else:)/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),\n      \"TupleExpression ComprehensionExpression ParamList ArgList ParenthesizedExpression\": /*@__PURE__*/delimitedIndent({\n        closing: \")\"\n      }),\n      \"DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression\": /*@__PURE__*/delimitedIndent({\n        closing: \"}\"\n      }),\n      \"ArrayExpression ArrayComprehensionExpression\": /*@__PURE__*/delimitedIndent({\n        closing: \"]\"\n      }),\n      \"String FormatString\": () => null,\n      Script: context => {\n        if (context.pos + /\\s*/.exec(context.textAfter)[0].length >= context.node.to) {\n          let endBody = null;\n          for (let cur = context.node, to = cur.to;;) {\n            cur = cur.lastChild;\n            if (!cur || cur.to != to) break;\n            if (cur.type.name == \"Body\") endBody = cur;\n          }\n          if (endBody) {\n            let bodyIndent = indentBody(context, endBody);\n            if (bodyIndent != null) return bodyIndent;\n          }\n        }\n        return context.continue();\n      }\n    }), /*@__PURE__*/foldNodeProp.add({\n      \"ArrayExpression DictionaryExpression SetExpression TupleExpression\": foldInside,\n      Body: (node, state) => ({\n        from: node.from + 1,\n        to: node.to - (node.to == state.doc.length ? 0 : 1)\n      })\n    })]\n  }),\n  languageData: {\n    closeBrackets: {\n      brackets: [\"(\", \"[\", \"{\", \"'\", '\"', \"'''\", '\"\"\"'],\n      stringPrefixes: [\"f\", \"fr\", \"rf\", \"r\", \"u\", \"b\", \"br\", \"rb\", \"F\", \"FR\", \"RF\", \"R\", \"U\", \"B\", \"BR\", \"RB\"]\n    },\n    commentTokens: {\n      line: \"#\"\n    },\n    indentOnInput: /^\\s*([\\}\\]\\)]|else:|elif |except |finally:)$/\n  }\n});\n/**\nPython language support.\n*/\nfunction python() {\n  return new LanguageSupport(pythonLanguage, [pythonLanguage.data.of({\n    autocomplete: localCompletionSource\n  }), pythonLanguage.data.of({\n    autocomplete: globalCompletion\n  })]);\n}\nexport { globalCompletion, localCompletionSource, python, pythonLanguage };","map":{"version":3,"names":["parser","syntaxTree","LRLanguage","indentNodeProp","delimitedIndent","foldNodeProp","foldInside","LanguageSupport","NodeWeakMap","IterMode","snippetCompletion","ifNotIn","completeFromList","cache","ScopeNodes","Set","defID","type","node","def","outer","id","getChild","gatherCompletions","FunctionDefinition","ClassDefinition","ForStatement","child","firstChild","nextSibling","name","ImportStatement","_node","_a","_b","isFrom","ch","AssignStatement","ParamList","prev","test","CapturePattern","AsPattern","__proto__","getScope","doc","cached","get","completions","top","sliceString","from","to","push","label","cursor","IncludeAnonymous","iterate","gather","has","c","set","Identifier","dontComplete","localCompletionSource","context","inner","state","resolveInner","pos","indexOf","isWord","sliceDoc","explicit","options","parent","concat","validFor","globals","map","n","snippets","detail","globalCompletion","indentBody","base","baseIndentFor","line","lineAt","text","length","lineIndent","textAfter","unit","pythonLanguage","define","configure","props","add","Body","continue","IfStatement","cx","baseIndent","TryStatement","closing","String FormatString","Script","exec","endBody","cur","lastChild","bodyIndent","languageData","closeBrackets","brackets","stringPrefixes","commentTokens","indentOnInput","python","data","of","autocomplete"],"sources":["/Users/madhavgoswami/Coding/Projects/InkCode-Fusion/client/node_modules/@codemirror/lang-python/dist/index.js"],"sourcesContent":["import { parser } from '@lezer/python';\nimport { syntaxTree, LRLanguage, indentNodeProp, delimitedIndent, foldNodeProp, foldInside, LanguageSupport } from '@codemirror/language';\nimport { NodeWeakMap, IterMode } from '@lezer/common';\nimport { snippetCompletion, ifNotIn, completeFromList } from '@codemirror/autocomplete';\n\nconst cache = /*@__PURE__*/new NodeWeakMap();\nconst ScopeNodes = /*@__PURE__*/new Set([\n    \"Script\", \"Body\",\n    \"FunctionDefinition\", \"ClassDefinition\", \"LambdaExpression\",\n    \"ForStatement\", \"MatchClause\"\n]);\nfunction defID(type) {\n    return (node, def, outer) => {\n        if (outer)\n            return false;\n        let id = node.node.getChild(\"VariableName\");\n        if (id)\n            def(id, type);\n        return true;\n    };\n}\nconst gatherCompletions = {\n    FunctionDefinition: /*@__PURE__*/defID(\"function\"),\n    ClassDefinition: /*@__PURE__*/defID(\"class\"),\n    ForStatement(node, def, outer) {\n        if (outer)\n            for (let child = node.node.firstChild; child; child = child.nextSibling) {\n                if (child.name == \"VariableName\")\n                    def(child, \"variable\");\n                else if (child.name == \"in\")\n                    break;\n            }\n    },\n    ImportStatement(_node, def) {\n        var _a, _b;\n        let { node } = _node;\n        let isFrom = ((_a = node.firstChild) === null || _a === void 0 ? void 0 : _a.name) == \"from\";\n        for (let ch = node.getChild(\"import\"); ch; ch = ch.nextSibling) {\n            if (ch.name == \"VariableName\" && ((_b = ch.nextSibling) === null || _b === void 0 ? void 0 : _b.name) != \"as\")\n                def(ch, isFrom ? \"variable\" : \"namespace\");\n        }\n    },\n    AssignStatement(node, def) {\n        for (let child = node.node.firstChild; child; child = child.nextSibling) {\n            if (child.name == \"VariableName\")\n                def(child, \"variable\");\n            else if (child.name == \":\" || child.name == \"AssignOp\")\n                break;\n        }\n    },\n    ParamList(node, def) {\n        for (let prev = null, child = node.node.firstChild; child; child = child.nextSibling) {\n            if (child.name == \"VariableName\" && (!prev || !/\\*|AssignOp/.test(prev.name)))\n                def(child, \"variable\");\n            prev = child;\n        }\n    },\n    CapturePattern: /*@__PURE__*/defID(\"variable\"),\n    AsPattern: /*@__PURE__*/defID(\"variable\"),\n    __proto__: null\n};\nfunction getScope(doc, node) {\n    let cached = cache.get(node);\n    if (cached)\n        return cached;\n    let completions = [], top = true;\n    function def(node, type) {\n        let name = doc.sliceString(node.from, node.to);\n        completions.push({ label: name, type });\n    }\n    node.cursor(IterMode.IncludeAnonymous).iterate(node => {\n        if (node.name) {\n            let gather = gatherCompletions[node.name];\n            if (gather && gather(node, def, top) || !top && ScopeNodes.has(node.name))\n                return false;\n            top = false;\n        }\n        else if (node.to - node.from > 8192) {\n            // Allow caching for bigger internal nodes\n            for (let c of getScope(doc, node.node))\n                completions.push(c);\n            return false;\n        }\n    });\n    cache.set(node, completions);\n    return completions;\n}\nconst Identifier = /^[\\w\\xa1-\\uffff][\\w\\d\\xa1-\\uffff]*$/;\nconst dontComplete = [\"String\", \"FormatString\", \"Comment\", \"PropertyName\"];\n/**\nCompletion source that looks up locally defined names in\nPython code.\n*/\nfunction localCompletionSource(context) {\n    let inner = syntaxTree(context.state).resolveInner(context.pos, -1);\n    if (dontComplete.indexOf(inner.name) > -1)\n        return null;\n    let isWord = inner.name == \"VariableName\" ||\n        inner.to - inner.from < 20 && Identifier.test(context.state.sliceDoc(inner.from, inner.to));\n    if (!isWord && !context.explicit)\n        return null;\n    let options = [];\n    for (let pos = inner; pos; pos = pos.parent) {\n        if (ScopeNodes.has(pos.name))\n            options = options.concat(getScope(context.state.doc, pos));\n    }\n    return {\n        options,\n        from: isWord ? inner.from : context.pos,\n        validFor: Identifier\n    };\n}\nconst globals = /*@__PURE__*/[\n    \"__annotations__\", \"__builtins__\", \"__debug__\", \"__doc__\", \"__import__\", \"__name__\",\n    \"__loader__\", \"__package__\", \"__spec__\",\n    \"False\", \"None\", \"True\"\n].map(n => ({ label: n, type: \"constant\" })).concat(/*@__PURE__*/[\n    \"ArithmeticError\", \"AssertionError\", \"AttributeError\", \"BaseException\", \"BlockingIOError\",\n    \"BrokenPipeError\", \"BufferError\", \"BytesWarning\", \"ChildProcessError\", \"ConnectionAbortedError\",\n    \"ConnectionError\", \"ConnectionRefusedError\", \"ConnectionResetError\", \"DeprecationWarning\",\n    \"EOFError\", \"Ellipsis\", \"EncodingWarning\", \"EnvironmentError\", \"Exception\", \"FileExistsError\",\n    \"FileNotFoundError\", \"FloatingPointError\", \"FutureWarning\", \"GeneratorExit\", \"IOError\",\n    \"ImportError\", \"ImportWarning\", \"IndentationError\", \"IndexError\", \"InterruptedError\",\n    \"IsADirectoryError\", \"KeyError\", \"KeyboardInterrupt\", \"LookupError\", \"MemoryError\",\n    \"ModuleNotFoundError\", \"NameError\", \"NotADirectoryError\", \"NotImplemented\", \"NotImplementedError\",\n    \"OSError\", \"OverflowError\", \"PendingDeprecationWarning\", \"PermissionError\", \"ProcessLookupError\",\n    \"RecursionError\", \"ReferenceError\", \"ResourceWarning\", \"RuntimeError\", \"RuntimeWarning\",\n    \"StopAsyncIteration\", \"StopIteration\", \"SyntaxError\", \"SyntaxWarning\", \"SystemError\",\n    \"SystemExit\", \"TabError\", \"TimeoutError\", \"TypeError\", \"UnboundLocalError\", \"UnicodeDecodeError\",\n    \"UnicodeEncodeError\", \"UnicodeError\", \"UnicodeTranslateError\", \"UnicodeWarning\", \"UserWarning\",\n    \"ValueError\", \"Warning\", \"ZeroDivisionError\"\n].map(n => ({ label: n, type: \"type\" }))).concat(/*@__PURE__*/[\n    \"bool\", \"bytearray\", \"bytes\", \"classmethod\", \"complex\", \"float\", \"frozenset\", \"int\", \"list\",\n    \"map\", \"memoryview\", \"object\", \"range\", \"set\", \"staticmethod\", \"str\", \"super\", \"tuple\", \"type\"\n].map(n => ({ label: n, type: \"class\" }))).concat(/*@__PURE__*/[\n    \"abs\", \"aiter\", \"all\", \"anext\", \"any\", \"ascii\", \"bin\", \"breakpoint\", \"callable\", \"chr\",\n    \"compile\", \"delattr\", \"dict\", \"dir\", \"divmod\", \"enumerate\", \"eval\", \"exec\", \"exit\", \"filter\",\n    \"format\", \"getattr\", \"globals\", \"hasattr\", \"hash\", \"help\", \"hex\", \"id\", \"input\", \"isinstance\",\n    \"issubclass\", \"iter\", \"len\", \"license\", \"locals\", \"max\", \"min\", \"next\", \"oct\", \"open\",\n    \"ord\", \"pow\", \"print\", \"property\", \"quit\", \"repr\", \"reversed\", \"round\", \"setattr\", \"slice\",\n    \"sorted\", \"sum\", \"vars\", \"zip\"\n].map(n => ({ label: n, type: \"function\" })));\nconst snippets = [\n    /*@__PURE__*/snippetCompletion(\"def ${name}(${params}):\\n\\t${}\", {\n        label: \"def\",\n        detail: \"function\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"for ${name} in ${collection}:\\n\\t${}\", {\n        label: \"for\",\n        detail: \"loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"while ${}:\\n\\t${}\", {\n        label: \"while\",\n        detail: \"loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"try:\\n\\t${}\\nexcept ${error}:\\n\\t${}\", {\n        label: \"try\",\n        detail: \"/ except block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"if ${}:\\n\\t\\n\", {\n        label: \"if\",\n        detail: \"block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"if ${}:\\n\\t${}\\nelse:\\n\\t${}\", {\n        label: \"if\",\n        detail: \"/ else block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"class ${name}:\\n\\tdef __init__(self, ${params}):\\n\\t\\t\\t${}\", {\n        label: \"class\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"import ${module}\", {\n        label: \"import\",\n        detail: \"statement\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"from ${module} import ${names}\", {\n        label: \"from\",\n        detail: \"import\",\n        type: \"keyword\"\n    })\n];\n/**\nAutocompletion for built-in Python globals and keywords.\n*/\nconst globalCompletion = /*@__PURE__*/ifNotIn(dontComplete, /*@__PURE__*/completeFromList(/*@__PURE__*/globals.concat(snippets)));\n\nfunction indentBody(context, node) {\n    let base = context.baseIndentFor(node);\n    let line = context.lineAt(context.pos, -1), to = line.from + line.text.length;\n    // Don't consider blank, deindented lines at the end of the\n    // block part of the block\n    if (/^\\s*($|#)/.test(line.text) &&\n        context.node.to < to + 100 &&\n        !/\\S/.test(context.state.sliceDoc(to, context.node.to)) &&\n        context.lineIndent(context.pos, -1) <= base)\n        return null;\n    // A normally deindenting keyword that appears at a higher\n    // indentation than the block should probably be handled by the next\n    // level\n    if (/^\\s*(else:|elif |except |finally:)/.test(context.textAfter) && context.lineIndent(context.pos, -1) > base)\n        return null;\n    return base + context.unit;\n}\n/**\nA language provider based on the [Lezer Python\nparser](https://github.com/lezer-parser/python), extended with\nhighlighting and indentation information.\n*/\nconst pythonLanguage = /*@__PURE__*/LRLanguage.define({\n    name: \"python\",\n    parser: /*@__PURE__*/parser.configure({\n        props: [\n            /*@__PURE__*/indentNodeProp.add({\n                Body: context => { var _a; return (_a = indentBody(context, context.node)) !== null && _a !== void 0 ? _a : context.continue(); },\n                IfStatement: cx => /^\\s*(else:|elif )/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),\n                TryStatement: cx => /^\\s*(except |finally:|else:)/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),\n                \"TupleExpression ComprehensionExpression ParamList ArgList ParenthesizedExpression\": /*@__PURE__*/delimitedIndent({ closing: \")\" }),\n                \"DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression\": /*@__PURE__*/delimitedIndent({ closing: \"}\" }),\n                \"ArrayExpression ArrayComprehensionExpression\": /*@__PURE__*/delimitedIndent({ closing: \"]\" }),\n                \"String FormatString\": () => null,\n                Script: context => {\n                    if (context.pos + /\\s*/.exec(context.textAfter)[0].length >= context.node.to) {\n                        let endBody = null;\n                        for (let cur = context.node, to = cur.to;;) {\n                            cur = cur.lastChild;\n                            if (!cur || cur.to != to)\n                                break;\n                            if (cur.type.name == \"Body\")\n                                endBody = cur;\n                        }\n                        if (endBody) {\n                            let bodyIndent = indentBody(context, endBody);\n                            if (bodyIndent != null)\n                                return bodyIndent;\n                        }\n                    }\n                    return context.continue();\n                }\n            }),\n            /*@__PURE__*/foldNodeProp.add({\n                \"ArrayExpression DictionaryExpression SetExpression TupleExpression\": foldInside,\n                Body: (node, state) => ({ from: node.from + 1, to: node.to - (node.to == state.doc.length ? 0 : 1) })\n            })\n        ],\n    }),\n    languageData: {\n        closeBrackets: {\n            brackets: [\"(\", \"[\", \"{\", \"'\", '\"', \"'''\", '\"\"\"'],\n            stringPrefixes: [\"f\", \"fr\", \"rf\", \"r\", \"u\", \"b\", \"br\", \"rb\",\n                \"F\", \"FR\", \"RF\", \"R\", \"U\", \"B\", \"BR\", \"RB\"]\n        },\n        commentTokens: { line: \"#\" },\n        indentOnInput: /^\\s*([\\}\\]\\)]|else:|elif |except |finally:)$/\n    }\n});\n/**\nPython language support.\n*/\nfunction python() {\n    return new LanguageSupport(pythonLanguage, [\n        pythonLanguage.data.of({ autocomplete: localCompletionSource }),\n        pythonLanguage.data.of({ autocomplete: globalCompletion }),\n    ]);\n}\n\nexport { globalCompletion, localCompletionSource, python, pythonLanguage };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}